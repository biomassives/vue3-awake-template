<!DOCTYPE html>
<html>
<head>
    <title>Interactive Exoplanet Visualization</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: white; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">Hover over an object</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/OrbitControls.js"></script>
    <script>

   document.addEventListener('DOMContentLoaded', function() {
            init();
            animate();
        });

        let scene, camera, renderer, controls;
        let TEST = false;  
        let sphere, raycaster, mouse = new THREE.Vector2(), INTERSECTED;
        const regions = [], radius = 50;
        let isDragging = false, allowFullRotation = false, hoverTimer = null;
        let zoomState = 0; // Zoom states

        function init() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0.01);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            controls.maxPolarAngle = Math.PI / 2;

            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x000, side: THREE.BackSide });
            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);

            window.addEventListener('resize', onWindowResize, false);
            loadAllQuadrants();
        }
/*
        let sphere; // Declare 'sphere' globally
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let INTERSECTED;
        const regions = [];
        const radius = 50; // Sphere radius for the visualization
    
        // Initialize the controls without 'const'
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.minDistance = 10;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI / 2;


        
        let allowFullRotation = false;  
        let hoverTimer = null;        
        let TEST = new URLSearchParams(window.location.search).has('test');        
        let zoomState = 0;  // 0 = initial, 1 = slow zoom, 2 = faster zoom, 3 = slower zoom, 4 = orbital position
*/

        


        
        // Function to extract URL parameters
        function getURLParameter(name) {
            return new URLSearchParams(window.location.search).get(name);
        }
        
        // Function to point the camera at a given planet
        function pointCameraAtPlanet(planetName) {
            let planetObject = scene.getObjectByName(planetName);
            if (planetObject) {
                camera.lookAt(planetObject.position);
            } else {
                console.warn("Planet not found: " + planetName);
            }
        }

    
        function loadAllQuadrants() {
            for (let i = 1; i <= 8; i++) {
                loadExoplanetData(`quadrant_${i}.json`); // Adjust the path if necessary
            }
        }
    
        function loadExoplanetData(jsonFilePath) {
            fetch(jsonFilePath)
                .then(response => response.json())
                .then(data => {
                    createExoplanetVisuals(data); // Process the data for each quadrant
                })
                .catch(error => console.error(`Failed to load data from ${jsonFilePath}:`, error));
        }
    

        let exoplanetsData = {}; // Declare this globally

        function createExoplanetVisuals(data) {
            const maxExoplanets = 200; 
            let exoplanetCount = 0; 

            data.forEach(planet => {
                if (exoplanetCount >= maxExoplanets) return; 

            try {
                const size = planet.pl_rade ? parseFloat(planet.pl_rade) * 0.1 : 0.5; 
                const geometry = new THREE.SphereGeometry(size, 32, 32);
                const color = planet.sy_dist === "N/A" ? 0xff0000 : Math.random() * 0xffffff; 
                const material = new THREE.MeshBasicMaterial({ color: 0xff00ff, opacity: 1 }); 
                const exoplanet = new THREE.Mesh(geometry, material); 
                exoplanet.name = planet.pl_name; // Ensure this matches the planet identifier

               // console.log("exoplanet variable exists:", typeof exoplanet !== 'undefined'); // This should log 'true'

                const ra = parseFloat(planet.ra);   
                const dec = parseFloat(planet.dec);
                const distance = planet.sy_dist === "N/A" ? 100 : parseFloat(planet.sy_dist); 

                const position = convertCelestialTo3D(ra, dec, distance); 
                // console.log(`Exoplanet ${planet.pl_name} (or other identifier) placed at: `, position); 
                exoplanet.position.set(position.x, position.y, position.z);

                exoplanet.userData = { id: planet.pl_name }; 
                scene.add(exoplanet);
                regions.push(exoplanet);

                exoplanetCount++; // Increment the counter on successful sphere creation

                // Dispatch a custom event (exoplanet is in scope here)
                const event = new CustomEvent('exoplanetCreated', { 
                    detail: {
                        exoplanet: exoplanet, // Pass the sphere object
                        planetData: planet     // Include the original planet data
                    }
                });
                window.dispatchEvent(event); 

            } catch (error) {
                console.error("Error creating sphere for exoplanet:", planet, error);
            }

            if (exoplanetCount >= maxExoplanets) {
                window.dispatchEvent(new Event('allExoplanetsLoaded')); 
            }
        });
        
        // At the end of the createExoplanetVisuals function
        if (exoplanetCount >= maxExoplanets) {
            window.dispatchEvent(new Event('allExoplanetsLoaded'));
        
            // Point the camera to the specified planet after all planets are loaded
            let planetParam = getURLParameter('planet');
            if (planetParam) {
                pointCameraAtPlanet(planetParam);
            }
        }


            

            
    }


    
        function convertCelestialTo3D(ra, dec, distance) {
            // Convert RA and Dec from degrees to radians
            ra = THREE.MathUtils.degToRad(ra);
            dec = THREE.MathUtils.degToRad(dec);

            let x = distance * Math.cos(dec) * Math.cos(ra);
            let y = distance * Math.sin(dec);
            let z = distance * Math.cos(dec) * Math.sin(ra);

            const positionVector = new THREE.Vector3(x, y, z);
            positionVector.normalize().multiplyScalar(radius);
            return { x: positionVector.x, y: positionVector.y, z: positionVector.z };
        }




        
        
        document.addEventListener('mousedown', function(event) {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        });
        
        document.addEventListener('mouseup', function(event) {
            isDragging = false;
        });
        
        document.addEventListener('mouseleave', function(event) {
            isDragging = false;
        });
        






            
        function onTouchMove(event) {
            event.preventDefault();
            if (isDragging) {
                const touch = event.touches[0];
                const deltaX = touch.clientX - previousTouchPosition.x;
                const deltaY = touch.clientY - previousTouchPosition.y;
        
                // Move everything within the sphere
                scene.position.x -= deltaX * 0.05;  
                scene.position.y += deltaY * 0.05; 
        
                previousTouchPosition = { 
                    x: touch.clientX, 
                    y: touch.clientY 
                }; 
            }
        }
        
    
    
    function highlightIntersected() {
        if (!INTERSECTED) return; // Safety check
    
   
        // Enlargement with GSAP animation
        gsap.to(INTERSECTED.scale, { 
            x: 2, 
            y: 2, 
            z: 2, 
            ease: "power1.out",
            duration: 0.5  // Animation duration in seconds
        });
    
        // Zoom effect with camera position
        const zoomAmount = 0.8; // Adjust zoom closeness (0.8 would be closer)
        gsap.to(camera.position, {
            x: INTERSECTED.position.x * zoomAmount,
            y: INTERSECTED.position.y * zoomAmount,
            z: INTERSECTED.position.z * zoomAmount,
            ease: "power1.out",
            duration: 0.5
        });
    
        INTERSECTED.material.opacity = 1;
        gsap.to(INTERSECTED.scale, { x: 2, y: 2, z: 2, ease: "power1.out" });
    
        // Display planet information
        document.getElementById('info').textContent = INTERSECTED.userData.id 
            + " (" + INTERSECTED.position.x.toFixed(2) + ", " + INTERSECTED.position.y.toFixed(2) + ", " + INTERSECTED.position.z.toFixed(2) + ")"; 
    
    
       INTERSECTED.material.opacity = 1;
        gsap.to(INTERSECTED.scale, { x: 1.5, y: 1.5, z: 1.5, ease: "power1.out" }); // Slight enlargement
    
        hoverTimer = setTimeout(() => {
            allowFullRotation = false; // Prevent normal rotation
            zoomState = 1; // Initiate zoom-in sequence
        }, 2000); // 2 second timer
    
        
    }
    
     
    
    function resetIntersected() {
        if (!INTERSECTED) return;  // Safety check
    
        // Reset scale
        gsap.to(INTERSECTED.scale, { 
            x: 1, 
            y: 1, 
            z: 1, 
            ease: "power1.out",
            duration: 0.5 
        });
    
         // Reset camera position (adjust zoomAmount for different zoom-out)
        const zoomOutAmount = 1.2; // Example value
        gsap.to(camera.position, {
            x: INTERSECTED.position.x * zoomOutAmount,
            y: INTERSECTED.position.y * zoomOutAmount,
            z: INTERSECTED.position.z * zoomOutAmount,
            ease: "power1.out",
            duration: 0.5
        });
        
        INTERSECTED.material.opacity = 0.5;
        gsap.to(INTERSECTED.scale, { x: 1, y: 1, z: 1, ease: "power1.out" });
        INTERSECTED = null;
        document.getElementById('info').textContent = 'Hover over an object';
    
        clearTimeout(hoverTimer);
        hoverTimer = null;
        zoomState = 0;
        allowFullRotation = false;
        
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    
    
    
    
    
    
    
            // Before your  function:
    let allDataLoaded = false;
    window.addEventListener('allExoplanetsLoaded', () => { allDataLoaded = true; });
    
    // Inside :
    
function animate() {
    requestAnimationFrame(animate);

    // Only update controls if user interactions are being used
    if (controls.enabled) {
        controls.update();
    }

    // Example dynamic rotation logic
    let rotationSpeed = 0.001; // Define rotation speed
    let rotationX = rotationSpeed * Date.now(); // This could be more complex depending on needs
    let rotationY = rotationSpeed * Date.now();

    if (allDataLoaded && !controls.enabled) { 
        // Manually rotate the camera around the origin
        camera.position.x = radius * Math.sin(rotationX) * Math.cos(rotationY);
        camera.position.y = radius * Math.sin(rotationY);
        camera.position.z = radius * Math.cos(rotationX) * Math.cos(rotationY);
        camera.lookAt(scene.position);
    }

    updateZoomState(); // Modularize zoom logic into a function for clarity

    renderer.render(scene, camera);
}


        
function updateZoomState() {
    if (zoomState > 0 && INTERSECTED) {
        let targetPosition = INTERSECTED.position.clone();
        switch (zoomState) {
            case 1:
                camera.position.lerp(targetPosition, 0.05); // Smooth transition
                if (camera.position.distanceTo(targetPosition) < radius * 0.75) {
                    zoomState = 2;
                }
                break;
            case 2:
                camera.position.lerp(targetPosition, 0.1);
                if (camera.position.distanceTo(targetPosition) < radius * 0.3) {
                    zoomState = 3;
                }
                break;
            case 3:
                camera.position.lerp(targetPosition, 0.15);
                if (camera.position.distanceTo(targetPosition) < radius * 0.15) {
                    zoomState = 4;
                }
                break;
            case 4:
                // Implement orbit logic if necessary or end zoom logic
                break;
        }
    }
}







    // Event listener for exoplanet creation
    window.addEventListener('exoplanetCreated', (event) => {
        const exoplanetData = event.detail;
        exoplanetsData[exoplanetData.exoplanet.userData.id] = exoplanetData;  
    });

    
    let planetParam = getURLParameter('planet');
    if (planetParam) {
        pointCameraAtPlanet(planetParam);
    }

        


    // Attach 'touchmove' listener
    document.addEventListener('touchmove', onTouchMove, false);



if (TEST) {

test('Camera rotates around the sphere', () => {
    // Arrange: Set up initial camera position
    const initialPosition = new THREE.Vector3(10, 10, 10); // Within the sphere's bounds
    camera.position.copy(initialPosition);

    // Act: Simulate rotation changes
    const rotationX = Math.PI / 2;
    const rotationY = Math.PI / 4;
    camera.position.set(radius * Math.sin(rotationX) * Math.cos(rotationY),
                        radius * Math.sin(rotationY),
                        radius * Math.cos(rotationX) * Math.cos(rotationY));

    // Assert: Camera position stays within bounds
    expect(camera.position.length()).toBeLessThanOrEqual(radius);
});


test('Exoplanet pulses when hovered', () => {
    // Arrange: Scene with sphere at (1, 1, 1)
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({ color: 0x00ff00 })); 
    scene.add(sphere);

    // ... set up raycasting and simulate mouse hover ...

    // Act: Call highlightIntersected()
    highlightIntersected(); 

    // Assert: (After a short delay to allow the GSAP animation)
    expect(sphere.material.color.r).toBeGreaterThan(0); // Check if color has changed
    expect(sphere.material.color.g).toBeGreaterThan(0);
    expect(sphere.material.color.b).toBeGreaterThan(0);
});



    

}

  

      

    </script>
    
</body>
</html>
